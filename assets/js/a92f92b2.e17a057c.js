"use strict";(self.webpackChunkaudio_queue_docs=self.webpackChunkaudio_queue_docs||[]).push([[88],{6092:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"core-concepts/performance-memory","title":"Performance & Memory Management","description":"Understanding performance optimization and memory management strategies for efficient audio applications.","source":"@site/docs/core-concepts/performance-memory.md","sourceDirName":"core-concepts","slug":"/core-concepts/performance-memory","permalink":"/audio-queue-docs/core-concepts/performance-memory","draft":false,"unlisted":false,"editUrl":"https://github.com/tonycarpenter21/audio-queue-docs/tree/main/docs/core-concepts/performance-memory.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Audio Lifecycle","permalink":"/audio-queue-docs/core-concepts/audio-lifecycle"},"next":{"title":"Queue Management","permalink":"/audio-queue-docs/api-reference/queue-management"}}');var t=r(4848),a=r(8453);const i={},s="Performance & Memory Management",l={},c=[{value:"Performance Overview",id:"performance-overview",level:2},{value:"Memory Management",id:"memory-management",level:2},{value:"Audio Element Lifecycle",id:"audio-element-lifecycle",level:3},{value:"Queue Size Optimization",id:"queue-size-optimization",level:3},{value:"CPU Performance Optimization",id:"cpu-performance-optimization",level:2},{value:"Event Handler Optimization",id:"event-handler-optimization",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Platform-Specific Optimizations",id:"platform-specific-optimizations",level:2},{value:"Mobile Performance",id:"mobile-performance",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Real-time Performance Tracking",id:"real-time-performance-tracking",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"General Performance Guidelines",id:"general-performance-guidelines",level:3},{value:"Next Steps",id:"next-steps",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"performance--memory-management",children:"Performance & Memory Management"})}),"\n",(0,t.jsx)(n.p,{children:"Understanding performance optimization and memory management strategies for efficient audio applications."}),"\n",(0,t.jsx)(n.h2,{id:"performance-overview",children:"Performance Overview"}),"\n",(0,t.jsx)(n.p,{children:"The audio-channel-queue package is designed for high performance, but understanding optimization strategies will help you build more efficient audio applications. This guide covers memory management, CPU optimization, and best practices for different scenarios."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { \r\n  queueAudio, \r\n  setChannelVolume, \r\n  getCurrentAudioInfo, \r\n  getAllChannelsInfo, \r\n  getQueueSnapshot \r\n} from 'audio-channel-queue';\r\n\r\n// Example: Performance monitoring\r\nclass AudioPerformanceMonitor {\r\n  private startTime: number = Date.now();\r\n  private memoryBaseline: number = 0;\r\n  \r\n  async monitorPerformance(): Promise<void> {\r\n    console.log('\ud83d\udd0d Starting performance monitoring...');\r\n    \r\n    // Baseline memory usage\r\n    if (performance.memory) {\r\n      this.memoryBaseline = performance.memory.usedJSHeapSize;\r\n    }\r\n    \r\n    // Monitor audio operations\r\n    await this.performAudioOperations();\r\n    \r\n    // Check final performance\r\n    this.reportPerformance();\r\n  }\r\n  \r\n  private async performAudioOperations(): Promise<void> {\r\n    // Queue multiple audio files\r\n    const startQueue = performance.now();\r\n    \r\n    for (let i = 0; i < 10; i++) {\r\n      await queueAudio(`./audio/track${i}.mp3`); // Using default channel 0\r\n    }\r\n    \r\n    const queueTime = performance.now() - startQueue;\r\n    console.log(`\u23f1\ufe0f Queuing 10 files took: ${queueTime.toFixed(2)}ms`);\r\n  }\r\n  \r\n  private reportPerformance(): void {\r\n    const totalTime = Date.now() - this.startTime;\r\n    \r\n    if (performance.memory) {\r\n      const memoryUsed = performance.memory.usedJSHeapSize - this.memoryBaseline;\r\n      console.log(`\ud83d\udcca Performance Report:`);\r\n      console.log(`   Total time: ${totalTime}ms`);\r\n      console.log(`   Memory used: ${(memoryUsed / 1024 / 1024).toFixed(2)} MB`);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(n.h3,{id:"audio-element-lifecycle",children:"Audio Element Lifecycle"}),"\n",(0,t.jsx)(n.p,{children:"The package automatically manages HTML audio elements, but understanding the lifecycle helps with optimization:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class AudioMemoryManager {\r\n  private channelUsage: Map<number, {\r\n    elementCount: number;\r\n    queueSize: number;\r\n    lastActivity: number;\r\n  }> = new Map();\r\n  \r\n  trackChannelUsage(): void {\r\n    console.log('\ud83e\udde0 Tracking memory usage by channel...');\r\n    \r\n    // Monitor multiple channels\r\n    for (let channel = 0; channel < 5; channel++) {\r\n      this.updateChannelUsage(channel);\r\n    }\r\n    \r\n    // Log usage report\r\n    this.logMemoryUsage();\r\n  }\r\n  \r\n  private updateChannelUsage(channel: number): void {\r\n    const snapshot = channel === 0 ? getQueueSnapshot() : getQueueSnapshot(channel);\r\n    const audioInfo = channel === 0 ? getCurrentAudioInfo() : getCurrentAudioInfo(channel);\r\n    \r\n    this.channelUsage.set(channel, {\r\n      elementCount: audioInfo ? 1 : 0, // 1 if active, 0 if idle\r\n      queueSize: snapshot.totalItems,\r\n      lastActivity: snapshot.isChannelActive ? Date.now() : 0\r\n    });\r\n  }\r\n  \r\n  private logMemoryUsage(): void {\r\n    console.log('\\n\ud83d\udcca Channel Memory Usage:');\r\n    \r\n    for (const [channel, usage] of this.channelUsage) {\r\n      const status = usage.elementCount > 0 ? 'Active' : 'Idle';\r\n      const lastActivity = usage.lastActivity > 0 \r\n        ? `${Date.now() - usage.lastActivity}ms ago` \r\n        : 'Never';\r\n      \r\n      console.log(`  Channel ${channel}: ${status}`);\r\n      console.log(`    Queue size: ${usage.queueSize} items`);\r\n      console.log(`    Last activity: ${lastActivity}`);\r\n    }\r\n  }\r\n  \r\n  getMemoryFootprint(): {\r\n    activeChannels: number;\r\n    totalQueueItems: number;\r\n    estimatedMemoryKB: number;\r\n  } {\r\n    let activeChannels = 0;\r\n    let totalQueueItems = 0;\r\n    \r\n    for (const usage of this.channelUsage.values()) {\r\n      if (usage.elementCount > 0) activeChannels++;\r\n      totalQueueItems += usage.queueSize;\r\n    }\r\n    \r\n    // Rough estimate: ~50KB per active channel + ~5KB per queued item\r\n    const estimatedMemoryKB = (activeChannels * 50) + (totalQueueItems * 5);\r\n    \r\n    return { activeChannels, totalQueueItems, estimatedMemoryKB };\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"queue-size-optimization",children:"Queue Size Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Manage queue sizes to prevent memory bloat:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class QueueOptimizer {\r\n  private readonly maxQueueSize: number = 10;\r\n  private readonly warningThreshold: number = 7;\r\n  \r\n  async optimizeQueues(): Promise<void> {\r\n    console.log('\ud83c\udfaf Optimizing queue sizes...');\r\n    \r\n    // Check all channels for optimization opportunities\r\n    for (let channel = 0; channel < 5; channel++) {\r\n      await this.optimizeChannel(channel);\r\n    }\r\n  }\r\n  \r\n  private async optimizeChannel(channel: number): Promise<void> {\r\n    const snapshot = channel === 0 ? getQueueSnapshot() : getQueueSnapshot(channel);\r\n    \r\n    if (snapshot.totalItems === 0) {\r\n      // Channel is idle - no optimization needed\r\n      return;\r\n    }\r\n    \r\n    if (snapshot.totalItems >= this.maxQueueSize) {\r\n      console.warn(`\u26a0\ufe0f Channel ${channel} queue at capacity (${snapshot.totalItems} items)`);\r\n      await this.handleOverloadedQueue(channel);\r\n    } else if (snapshot.totalItems >= this.warningThreshold) {\r\n      console.log(`\ud83d\udcc8 Channel ${channel} queue approaching capacity (${snapshot.totalItems} items)`);\r\n      this.handleWarningThreshold(channel);\r\n    }\r\n  }\r\n  \r\n  private async handleOverloadedQueue(channel: number): Promise<void> {\r\n    console.log(`\ud83d\udea8 Handling overloaded queue on channel ${channel}`);\r\n    \r\n    // Option 1: Stop current audio to clear queue faster\r\n    // if (channel === 0) {\r\n    //   stopCurrentAudioInChannel();\r\n    // } else {\r\n    //   stopCurrentAudioInChannel(channel);\r\n    // }\r\n    \r\n    // Option 2: Log warning and let queue naturally drain\r\n    console.log('Queue will drain naturally - consider reducing queue rate');\r\n    \r\n    // Option 3: Implement smart queue management\r\n    this.implementSmartQueue(channel);\r\n  }\r\n  \r\n  private handleWarningThreshold(channel: number): void {\r\n    console.log(`\u26a1 Channel ${channel} entering warning threshold`);\r\n    // Could implement rate limiting or preemptive queue management\r\n  }\r\n  \r\n  private implementSmartQueue(channel: number): void {\r\n    // Smart queue management - could implement:\r\n    // - Priority-based item removal\r\n    // - Queue compaction\r\n    // - Dynamic queue size limits\r\n    console.log(`\ud83e\udde0 Implementing smart queue management for channel ${channel}`);\r\n  }\r\n  \r\n  getOptimizationReport(): {\r\n    [channel: number]: {\r\n      queueSize: number;\r\n      status: 'optimal' | 'warning' | 'critical';\r\n      recommendation: string;\r\n    };\r\n  } {\r\n    const report: any = {};\r\n    \r\n    for (let channel = 0; channel < 5; channel++) {\r\n      const snapshot = channel === 0 ? getQueueSnapshot() : getQueueSnapshot(channel);\r\n      let status: 'optimal' | 'warning' | 'critical';\r\n      let recommendation: string;\r\n      \r\n      if (snapshot.totalItems >= this.maxQueueSize) {\r\n        status = 'critical';\r\n        recommendation = 'Reduce queue input rate or clear queue';\r\n      } else if (snapshot.totalItems >= this.warningThreshold) {\r\n        status = 'warning';\r\n        recommendation = 'Monitor queue growth closely';\r\n      } else {\r\n        status = 'optimal';\r\n        recommendation = 'Queue size is optimal';\r\n      }\r\n      \r\n      report[channel] = {\r\n        queueSize: snapshot.totalItems,\r\n        status,\r\n        recommendation\r\n      };\r\n    }\r\n    \r\n    return report;\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"cpu-performance-optimization",children:"CPU Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"event-handler-optimization",children:"Event Handler Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Optimize event handlers to reduce CPU load:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class EventOptimizer {\r\n  private progressThrottle: number = 100; // Update every 100ms\r\n  private lastProgressUpdate: Map<number, number> = new Map();\r\n  private batchedUpdates: Map<number, any> = new Map();\r\n  \r\n  setupOptimizedEventHandlers(): void {\r\n    console.log('\u26a1 Setting up optimized event handlers...');\r\n    \r\n    // Optimized progress handlers\r\n    for (let channel = 0; channel < 3; channel++) {\r\n      this.setupThrottledProgress(channel);\r\n      this.setupBatchedQueueUpdates(channel);\r\n    }\r\n  }\r\n  \r\n  private setupThrottledProgress(channel: number): void {\r\n    onAudioProgress(channel, (info) => {\r\n      const now = Date.now();\r\n      const lastUpdate = this.lastProgressUpdate.get(channel) || 0;\r\n      \r\n      // Throttle progress updates\r\n      if (now - lastUpdate >= this.progressThrottle) {\r\n        this.lastProgressUpdate.set(channel, now);\r\n        this.handleOptimizedProgress(channel, info);\r\n      }\r\n    });\r\n  }\r\n  \r\n  private setupBatchedQueueUpdates(channel: number): void {\r\n    onQueueChange(channel, (snapshot) => {\r\n      // Batch queue updates to avoid excessive UI updates\r\n      this.batchedUpdates.set(channel, snapshot);\r\n      \r\n      // Process batched updates after a short delay\r\n      setTimeout(() => {\r\n        this.processBatchedUpdates();\r\n      }, 50);\r\n    });\r\n  }\r\n  \r\n  private handleOptimizedProgress(channel: number, info: AudioProgressInfo): void {\r\n    // Lightweight progress handling\r\n    const percentage = Math.round(info.progress * 100);\r\n    \r\n    // Only update UI for significant changes\r\n    if (percentage % 5 === 0) {\r\n      this.updateProgressUI(channel, percentage);\r\n    }\r\n  }\r\n  \r\n  private processBatchedUpdates(): void {\r\n    for (const [channel, snapshot] of this.batchedUpdates) {\r\n      this.updateQueueUI(channel, snapshot);\r\n    }\r\n    \r\n    this.batchedUpdates.clear();\r\n  }\r\n  \r\n  private updateProgressUI(channel: number, percentage: number): void {\r\n    // Efficient UI update\r\n    console.log(`Progress Channel ${channel}: ${percentage}%`);\r\n  }\r\n  \r\n  private updateQueueUI(channel: number, snapshot: QueueSnapshot): void {\r\n    // Efficient queue UI update\r\n    console.log(`Queue Channel ${channel}: ${snapshot.totalItems} items`);\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,t.jsx)(n.p,{children:"Perform batch operations for better performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class BatchOperationManager {\r\n  async performBatchOperations(): Promise<void> {\r\n    console.log('\ud83d\udd04 Performing batch operations...');\r\n    \r\n    const startTime = performance.now();\r\n    \r\n    // Batch audio queueing\r\n    await this.batchQueueAudio();\r\n    \r\n    // Batch volume adjustments\r\n    this.batchVolumeAdjustments();\r\n    \r\n    // Batch information retrieval\r\n    this.batchInformationRetrieval();\r\n    \r\n    const endTime = performance.now();\r\n    console.log(`\u23f1\ufe0f Batch operations completed in ${(endTime - startTime).toFixed(2)}ms`);\r\n  }\r\n  \r\n  private async batchQueueAudio(): Promise<void> {\r\n    const audioFiles = [\r\n      './audio/track1.mp3',\r\n      './audio/track2.mp3',\r\n      './audio/track3.mp3',\r\n      './audio/track4.mp3',\r\n      './audio/track5.mp3'\r\n    ];\r\n    \r\n    // Queue all files simultaneously for better performance\r\n    const queuePromises = audioFiles.map((file, index) => {\r\n      const channel = Math.floor(index / 2);\r\n      return channel === 0 ? queueAudio(file) : queueAudio(file, channel);\r\n    });\r\n    \r\n    await Promise.all(queuePromises);\r\n    console.log(`\u2713 Batch queued ${audioFiles.length} files`);\r\n  }\r\n  \r\n  private batchVolumeAdjustments(): void {\r\n    // Batch volume changes to reduce individual operations\r\n    const volumeChanges = [\r\n      { channel: 0, volume: 0.8 },\r\n      { channel: 1, volume: 0.6 },\r\n      { channel: 2, volume: 1.0 },\r\n      { channel: 3, volume: 0.4 }\r\n    ];\r\n    \r\n    volumeChanges.forEach(({ channel, volume }) => {\r\n      setChannelVolume(channel, volume);\r\n    });\r\n    \r\n    console.log(`\u2713 Batch adjusted ${volumeChanges.length} channel volumes`);\r\n  }\r\n  \r\n  private batchInformationRetrieval(): void {\r\n    // Retrieve information for multiple channels efficiently\r\n    const channels = [0, 1, 2, 3, 4];\r\n    \r\n    const channelData = channels.map(channel => ({\r\n      channel,\r\n      audioInfo: channel === 0 ? getCurrentAudioInfo() : getCurrentAudioInfo(channel),\r\n      queueSnapshot: channel === 0 ? getQueueSnapshot() : getQueueSnapshot(channel)\r\n    }));\r\n    \r\n    console.log(`\u2713 Retrieved information for ${channelData.length} channels`);\r\n    \r\n    // Process the data efficiently\r\n    const activeChannels = channelData.filter(data => data.audioInfo !== null);\r\n    const totalQueueItems = channelData.reduce(\r\n      (sum, data) => sum + data.queueSnapshot.totalItems, \r\n      0\r\n    );\r\n    \r\n    console.log(`   Active channels: ${activeChannels.length}`);\r\n    console.log(`   Total queue items: ${totalQueueItems}`);\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"platform-specific-optimizations",children:"Platform-Specific Optimizations"}),"\n",(0,t.jsx)(n.h3,{id:"mobile-performance",children:"Mobile Performance"}),"\n",(0,t.jsx)(n.p,{children:"Optimize for mobile devices with limited resources:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class MobileOptimizer {\r\n  private isMobile: boolean;\r\n  private maxChannels: number;\r\n  private maxQueueSize: number;\r\n  \r\n  constructor() {\r\n    this.isMobile = this.detectMobile();\r\n    this.maxChannels = this.isMobile ? 3 : 8;\r\n    this.maxQueueSize = this.isMobile ? 5 : 15;\r\n    \r\n    console.log(`\ud83d\udcf1 Mobile optimization: ${this.isMobile ? 'Enabled' : 'Disabled'}`);\r\n  }\r\n  \r\n  private detectMobile(): boolean {\r\n    return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n  }\r\n  \r\n  setupMobileOptimizations(): void {\r\n    if (!this.isMobile) {\r\n      console.log('\ud83d\udcbb Desktop mode - using full performance profile');\r\n      return;\r\n    }\r\n    \r\n    console.log('\ud83d\udcf1 Mobile mode - applying performance optimizations');\r\n    \r\n    this.limitChannelUsage();\r\n    this.optimizeQueueSizes();\r\n    this.setupMobileEventHandling();\r\n    this.optimizeMemoryUsage();\r\n  }\r\n  \r\n  private limitChannelUsage(): void {\r\n    console.log(`\ud83d\udd22 Limiting to ${this.maxChannels} channels for mobile`);\r\n    \r\n    // Track channel usage and warn if exceeded\r\n    setInterval(() => {\r\n      this.checkChannelUsage();\r\n    }, 5000);\r\n  }\r\n  \r\n  private checkChannelUsage(): void {\r\n    const allChannelsInfo = getAllChannelsInfo();\r\n    const activeChannels = Object.keys(allChannelsInfo).length;\r\n    \r\n    if (activeChannels > this.maxChannels) {\r\n      console.warn(`\u26a0\ufe0f Using ${activeChannels} channels, recommended max: ${this.maxChannels}`);\r\n    }\r\n  }\r\n  \r\n  private optimizeQueueSizes(): void {\r\n    console.log(`\ud83d\udccb Limiting queue size to ${this.maxQueueSize} items for mobile`);\r\n    \r\n    // Monitor queue sizes across channels\r\n    setInterval(() => {\r\n      for (let channel = 0; channel < this.maxChannels; channel++) {\r\n        const snapshot = getQueueSnapshot(channel);\r\n        \r\n        if (snapshot.totalItems > this.maxQueueSize) {\r\n          console.warn(`\u26a0\ufe0f Channel ${channel} queue (${snapshot.totalItems}) exceeds mobile limit (${this.maxQueueSize})`);\r\n        }\r\n      }\r\n    }, 3000);\r\n  }\r\n  \r\n  private setupMobileEventHandling(): void {\r\n    // More aggressive throttling for mobile\r\n    const mobileProgressThrottle = 200; // Update every 200ms instead of 100ms\r\n    \r\n    for (let channel = 0; channel < this.maxChannels; channel++) {\r\n      let lastUpdate = 0;\r\n      \r\n      onAudioProgress(channel, (info) => {\r\n        const now = Date.now();\r\n        \r\n        if (now - lastUpdate >= mobileProgressThrottle) {\r\n          lastUpdate = now;\r\n          this.handleMobileProgress(channel, info);\r\n        }\r\n      });\r\n    }\r\n  }\r\n  \r\n  private handleMobileProgress(channel: number, info: AudioProgressInfo): void {\r\n    // Lightweight progress handling for mobile\r\n    const percentage = Math.round(info.progress * 100);\r\n    \r\n    // Only update for larger increments on mobile\r\n    if (percentage % 10 === 0) {\r\n      console.log(`\ud83d\udcf1 Mobile Progress ${channel}: ${percentage}%`);\r\n    }\r\n  }\r\n  \r\n  private optimizeMemoryUsage(): void {\r\n    // More frequent cleanup on mobile\r\n    setInterval(() => {\r\n      this.performMobileCleanup();\r\n    }, 10000); // Every 10 seconds\r\n  }\r\n  \r\n  private performMobileCleanup(): void {\r\n    // Force garbage collection if available (Chrome)\r\n    if (window.gc && typeof window.gc === 'function') {\r\n      window.gc();\r\n    }\r\n    \r\n    // Log memory usage if available\r\n    if (performance.memory) {\r\n      const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;\r\n      console.log(`\ud83d\udcca Mobile Memory: ${memoryMB.toFixed(1)} MB`);\r\n      \r\n      if (memoryMB > 50) { // Alert if using more than 50MB\r\n        console.warn('\u26a0\ufe0f High memory usage detected on mobile device');\r\n      }\r\n    }\r\n  }\r\n  \r\n  getMobilePerformanceReport(): {\r\n    isMobile: boolean;\r\n    maxChannels: number;\r\n    maxQueueSize: number;\r\n    currentMemoryMB: number;\r\n    recommendations: string[];\r\n  } {\r\n    const recommendations: string[] = [];\r\n    \r\n    if (this.isMobile) {\r\n      recommendations.push(`Limit to ${this.maxChannels} channels`);\r\n      recommendations.push(`Keep queue sizes under ${this.maxQueueSize} items`);\r\n      recommendations.push('Use throttled event handlers');\r\n      recommendations.push('Monitor memory usage closely');\r\n    }\r\n    \r\n    return {\r\n      isMobile: this.isMobile,\r\n      maxChannels: this.maxChannels,\r\n      maxQueueSize: this.maxQueueSize,\r\n      currentMemoryMB: performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 0,\r\n      recommendations\r\n    };\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,t.jsx)(n.h3,{id:"real-time-performance-tracking",children:"Real-time Performance Tracking"}),"\n",(0,t.jsx)(n.p,{children:"Monitor performance in real-time to catch issues early:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class RealTimePerformanceMonitor {\r\n  private metrics = {\r\n    startTime: Date.now(),\r\n    operationCount: 0,\r\n    averageOperationTime: 0,\r\n    memoryPeakMB: 0,\r\n    errorCount: 0,\r\n    lastGCTime: 0\r\n  };\r\n  \r\n  private operationTimes: number[] = [];\r\n  private maxOperationHistory = 100;\r\n  \r\n  startMonitoring(): void {\r\n    console.log('\ud83d\udd0d Starting real-time performance monitoring...');\r\n    \r\n    this.setupPerformanceHooks();\r\n    this.startPeriodicReporting();\r\n    this.setupMemoryMonitoring();\r\n  }\r\n  \r\n  private setupPerformanceHooks(): void {\r\n    // Wrap audio operations to measure performance\r\n    this.hookAudioOperations();\r\n    \r\n    // Monitor for performance issues\r\n    this.setupPerformanceAlerts();\r\n  }\r\n  \r\n  private hookAudioOperations(): void {\r\n    // This is conceptual - in practice you'd wrap the operations\r\n    console.log('\ud83c\udfa3 Hooking audio operations for performance measurement');\r\n    \r\n    // Example: Measure queue operations\r\n    const originalQueueAudio = queueAudio;\r\n    \r\n    // Note: This is just for demonstration - don't actually override the function\r\n    // window.queueAudio = async (...args) => {\r\n    //   const start = performance.now();\r\n    //   const result = await originalQueueAudio(...args);\r\n    //   const duration = performance.now() - start;\r\n    //   this.recordOperation(duration);\r\n    //   return result;\r\n    // };\r\n  }\r\n  \r\n  private recordOperation(duration: number): void {\r\n    this.metrics.operationCount++;\r\n    this.operationTimes.push(duration);\r\n    \r\n    // Keep only recent operations\r\n    if (this.operationTimes.length > this.maxOperationHistory) {\r\n      this.operationTimes.shift();\r\n    }\r\n    \r\n    // Calculate rolling average\r\n    this.metrics.averageOperationTime = \r\n      this.operationTimes.reduce((a, b) => a + b, 0) / this.operationTimes.length;\r\n    \r\n    // Alert for slow operations\r\n    if (duration > 100) { // Operations taking more than 100ms\r\n      console.warn(`\u26a0\ufe0f Slow operation detected: ${duration.toFixed(2)}ms`);\r\n    }\r\n  }\r\n  \r\n  private setupPerformanceAlerts(): void {\r\n    // Alert for performance degradation\r\n    setInterval(() => {\r\n      if (this.metrics.averageOperationTime > 50) {\r\n        console.warn(`\u26a0\ufe0f Performance degradation: avg operation time ${this.metrics.averageOperationTime.toFixed(2)}ms`);\r\n      }\r\n    }, 5000);\r\n  }\r\n  \r\n  private startPeriodicReporting(): void {\r\n    setInterval(() => {\r\n      this.generatePerformanceReport();\r\n    }, 30000); // Every 30 seconds\r\n  }\r\n  \r\n  private setupMemoryMonitoring(): void {\r\n    setInterval(() => {\r\n      if (performance.memory) {\r\n        const currentMemoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;\r\n        \r\n        if (currentMemoryMB > this.metrics.memoryPeakMB) {\r\n          this.metrics.memoryPeakMB = currentMemoryMB;\r\n        }\r\n        \r\n        // Alert for memory leaks\r\n        if (currentMemoryMB > 100) { // More than 100MB\r\n          console.warn(`\u26a0\ufe0f High memory usage: ${currentMemoryMB.toFixed(1)} MB`);\r\n        }\r\n      }\r\n    }, 2000);\r\n  }\r\n  \r\n  private generatePerformanceReport(): void {\r\n    const uptime = Date.now() - this.metrics.startTime;\r\n    const operationsPerSecond = this.metrics.operationCount / (uptime / 1000);\r\n    \r\n    console.log('\\n\ud83d\udcca Performance Report:');\r\n    console.log(`   Uptime: ${Math.round(uptime / 1000)}s`);\r\n    console.log(`   Operations: ${this.metrics.operationCount} (${operationsPerSecond.toFixed(2)}/s)`);\r\n    console.log(`   Avg operation time: ${this.metrics.averageOperationTime.toFixed(2)}ms`);\r\n    console.log(`   Memory peak: ${this.metrics.memoryPeakMB.toFixed(1)} MB`);\r\n    console.log(`   Errors: ${this.metrics.errorCount}`);\r\n    \r\n    // Performance score\r\n    const performanceScore = this.calculatePerformanceScore();\r\n    console.log(`   Performance score: ${performanceScore}/100`);\r\n  }\r\n  \r\n  private calculatePerformanceScore(): number {\r\n    let score = 100;\r\n    \r\n    // Deduct for slow operations\r\n    if (this.metrics.averageOperationTime > 50) {\r\n      score -= 20;\r\n    } else if (this.metrics.averageOperationTime > 25) {\r\n      score -= 10;\r\n    }\r\n    \r\n    // Deduct for high memory usage\r\n    if (this.metrics.memoryPeakMB > 100) {\r\n      score -= 30;\r\n    } else if (this.metrics.memoryPeakMB > 50) {\r\n      score -= 15;\r\n    }\r\n    \r\n    // Deduct for errors\r\n    score -= this.metrics.errorCount * 5;\r\n    \r\n    return Math.max(0, score);\r\n  }\r\n  \r\n  getDetailedMetrics(): typeof this.metrics & {\r\n    operationTimes: number[];\r\n    currentMemoryMB: number;\r\n    performanceScore: number;\r\n  } {\r\n    return {\r\n      ...this.metrics,\r\n      operationTimes: [...this.operationTimes],\r\n      currentMemoryMB: performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 0,\r\n      performanceScore: this.calculatePerformanceScore()\r\n    };\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,t.jsx)(n.h3,{id:"general-performance-guidelines",children:"General Performance Guidelines"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class PerformanceBestPractices {\r\n  static getRecommendations(): {\r\n    category: string;\r\n    recommendations: string[];\r\n  }[] {\r\n    return [\r\n      {\r\n        category: 'Queue Management',\r\n        recommendations: [\r\n          'Keep queue sizes under 10-15 items for optimal performance',\r\n          'Use priority queuing sparingly to avoid frequent interruptions',\r\n          'Monitor queue growth and implement throttling if needed',\r\n          'Clear unused queues periodically'\r\n        ]\r\n      },\r\n      {\r\n        category: 'Event Handling',\r\n        recommendations: [\r\n          'Throttle progress event handlers to 100ms intervals',\r\n          'Batch UI updates to reduce DOM manipulation',\r\n          'Use lightweight event handlers for high-frequency events',\r\n          'Clean up event listeners when components unmount'\r\n        ]\r\n      },\r\n      {\r\n        category: 'Memory Management',\r\n        recommendations: [\r\n          'Limit simultaneous active channels (3-4 for mobile, 8-10 for desktop)',\r\n          'Monitor memory usage in long-running applications',\r\n          'Avoid memory leaks by properly managing event listeners',\r\n          'Use performance.memory API for memory monitoring'\r\n        ]\r\n      },\r\n      {\r\n        category: 'Mobile Optimization',\r\n        recommendations: [\r\n          'Use more conservative limits on mobile devices',\r\n          'Implement longer throttling intervals for events',\r\n          'Monitor battery usage and thermal throttling',\r\n          'Test thoroughly on various mobile devices'\r\n        ]\r\n      },\r\n      {\r\n        category: 'Development & Testing',\r\n        recommendations: [\r\n          'Use performance profiling tools during development',\r\n          'Test with realistic audio file sizes and quantities',\r\n          'Monitor performance metrics in production',\r\n          'Implement fallback strategies for low-performance devices'\r\n        ]\r\n      }\r\n    ];\r\n  }\r\n  \r\n  static logRecommendations(): void {\r\n    console.log('\ud83c\udfaf Audio Channel Queue Performance Best Practices:\\n');\r\n    \r\n    this.getRecommendations().forEach(({ category, recommendations }) => {\r\n      console.log(`\ud83d\udccb ${category}:`);\r\n      recommendations.forEach(rec => {\r\n        console.log(`   \u2022 ${rec}`);\r\n      });\r\n      console.log('');\r\n    });\r\n  }\r\n}\r\n\r\n// Usage\r\nPerformanceBestPractices.logRecommendations();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(n.p,{children:"Now that you understand performance and memory management, explore:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../api-reference/queue-management",children:"API Reference"})})," - Complete function documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../getting-started/basic-usage",children:"Examples"})})," - Performance-optimized real-world examples"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../advanced/volume-ducking",children:"Advanced Features"})})," - Complex optimization scenarios"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../migration/troubleshooting",children:"Migration & Help"})})," - Upgrading and troubleshooting guides"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var o=r(6540);const t={},a=o.createContext(t);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);
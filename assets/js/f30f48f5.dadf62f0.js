"use strict";(self.webpackChunkaudio_queue_docs=self.webpackChunkaudio_queue_docs||[]).push([[327],{2012:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"api-reference/audio-information","title":"Audio Information","description":"Retrieve real-time information about audio playback, queue status, and channel states.","source":"@site/docs/api-reference/audio-information.md","sourceDirName":"api-reference","slug":"/api-reference/audio-information","permalink":"/audio-queue-docs/api-reference/audio-information","draft":false,"unlisted":false,"editUrl":"https://github.com/tonycarpenter21/audio-queue-docs/tree/main/docs/api-reference/audio-information.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Event Listeners","permalink":"/audio-queue-docs/api-reference/event-listeners"},"next":{"title":"Types & Interfaces","permalink":"/audio-queue-docs/api-reference/types-interfaces"}}');var s=r(4848),t=r(8453);const i={},o="Audio Information",l={},u=[{value:"getCurrentAudioInfo",id:"getcurrentaudioinfo",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:3},{value:"AudioInfo Properties",id:"audioinfo-properties",level:3},{value:"Examples",id:"examples",level:3},{value:"Real-world Usage",id:"real-world-usage",level:3},{value:"getAllChannelsInfo",id:"getallchannelsinfo",level:2},{value:"Syntax",id:"syntax-1",level:3},{value:"Returns",id:"returns-1",level:3},{value:"Examples",id:"examples-1",level:3},{value:"Multi-Channel Dashboard",id:"multi-channel-dashboard",level:3},{value:"getQueueSnapshot",id:"getqueuesnapshot",level:2},{value:"Syntax",id:"syntax-2",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Returns",id:"returns-2",level:3},{value:"QueueSnapshot Properties",id:"queuesnapshot-properties",level:3},{value:"Examples",id:"examples-2",level:3},{value:"Real-world Usage",id:"real-world-usage-1",level:3},{value:"Queue Analysis",id:"queue-analysis",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"audio-information",children:"Audio Information"})}),"\n",(0,s.jsx)(e.p,{children:"Retrieve real-time information about audio playback, queue status, and channel states."}),"\n",(0,s.jsx)(e.h2,{id:"getcurrentaudioinfo",children:"getCurrentAudioInfo"}),"\n",(0,s.jsx)(e.p,{children:"Get detailed information about the currently playing audio on a specific channel."}),"\n",(0,s.jsx)(e.h3,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"getCurrentAudioInfo(channelNumber?: number): AudioInfo | null\n"})}),"\n",(0,s.jsx)(e.h3,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"channelNumber"})," (number, optional): The channel number to query (defaults to 0)"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"AudioInfo | null"}),": Information about current audio, or ",(0,s.jsx)(e.code,{children:"null"})," if nothing is playing"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"audioinfo-properties",children:"AudioInfo Properties"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface AudioInfo {\r\n  audioElement: HTMLAudioElement;\r\n  currentTime: number;\r\n  duration: number;\r\n  fileName: string;\r\n  isLooping: boolean;\r\n  isPaused: boolean;\r\n  isPlaying: boolean;\r\n  volume: number;\r\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"import { getCurrentAudioInfo, queueAudio } from 'audio-channel-queue';\r\n\r\n// Start playing audio\r\nawait queueAudio('/audio/music.mp3');\r\n\r\n// Get current audio information (using default channel 0)\r\nconst audioInfo = getCurrentAudioInfo();\r\nif (audioInfo) {\r\n  console.log(`Playing: ${audioInfo.fileName}`);\r\n  console.log(`Progress: ${audioInfo.currentTime}/${audioInfo.duration}ms`);\r\n  console.log(`Volume: ${audioInfo.volume}`);\r\n  console.log(`Paused: ${audioInfo.isPaused}`);\r\n}\r\n\r\n// For channel 0 (default), you can omit the channel number\r\nconst info = getCurrentAudioInfo(); // Same as getCurrentAudioInfo(0)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"real-world-usage",children:"Real-world Usage"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:'class AudioStatusDisplay {\r\n  private statusElement: HTMLElement | null = null;\r\n\r\n  constructor() {\r\n    this.statusElement = document.getElementById(\'audio-status\');\r\n    this.startStatusUpdates();\r\n  }\r\n\r\n  private startStatusUpdates(): void {\r\n    setInterval(() => {\r\n      this.updateStatus();\r\n    }, 100); // Update every 100ms\r\n  }\r\n\r\n  private updateStatus(): void {\r\n    const audioInfo = getCurrentAudioInfo(); // Using default channel 0\r\n    \r\n    if (audioInfo && this.statusElement) {\r\n      const progress = (audioInfo.currentTime / audioInfo.duration) * 100;\r\n      const timeDisplay = this.formatTime(audioInfo.currentTime);\r\n      const totalTime = this.formatTime(audioInfo.duration);\r\n      \r\n      this.statusElement.innerHTML = `\r\n        <div class="now-playing">\r\n          <h3>Now Playing</h3>\r\n          <div class="track-name">${audioInfo.fileName}</div>\r\n          <div class="progress-container">\r\n            <div class="progress-bar" style="width: ${progress}%"></div>\r\n            <div class="time-display">${timeDisplay} / ${totalTime}</div>\r\n          </div>\r\n          <div class="audio-controls">\r\n            <span class="volume">Volume: ${Math.round(audioInfo.volume * 100)}%</span>\r\n            <span class="status">${audioInfo.isPaused ? \'\u23f8\ufe0f Paused\' : \'\u25b6\ufe0f Playing\'}</span>\r\n            ${audioInfo.isLooping ? \'<span class="loop">\ud83d\udd01 Loop</span>\' : \'\'}\r\n          </div>\r\n        </div>\r\n      `;\r\n    } else if (this.statusElement) {\r\n      this.statusElement.innerHTML = \'<div class="no-audio">No audio playing</div>\';\r\n    }\r\n  }\r\n\r\n  private formatTime(milliseconds: number): string {\r\n    const seconds = Math.floor(milliseconds / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const remainingSeconds = seconds % 60;\r\n    return `${minutes}:${remainingSeconds.toString().padStart(2, \'0\')}`;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"getallchannelsinfo",children:"getAllChannelsInfo"}),"\n",(0,s.jsx)(e.p,{children:"Get information about all active audio channels."}),"\n",(0,s.jsx)(e.h3,{id:"syntax-1",children:"Syntax"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"getAllChannelsInfo(): { [channelNumber: number]: AudioInfo | null }\n"})}),"\n",(0,s.jsx)(e.h3,{id:"returns-1",children:"Returns"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"Object"}),": Map of channel numbers to their current audio information"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"examples-1",children:"Examples"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"import { getAllChannelsInfo, queueAudio } from 'audio-channel-queue';\r\n\r\n// Start audio on multiple channels\r\nawait queueAudio('/audio/music.mp3', 0);\r\nawait queueAudio('/audio/sfx.wav', 1);\r\n\r\n// Get information for all channels\r\nconst allChannels = getAllChannelsInfo();\r\n\r\nconsole.log('All Channel Information:');\r\nObject.entries(allChannels).forEach(([channel, info]) => {\r\n  if (info) {\r\n    console.log(`Channel ${channel}: Playing ${info.fileName}`);\r\n    console.log(`  Progress: ${Math.round((info.currentTime / info.duration) * 100)}%`);\r\n    console.log(`  Volume: ${Math.round(info.volume * 100)}%`);\r\n    console.log(`  Status: ${info.isPaused ? 'Paused' : 'Playing'}`);\r\n  } else {\r\n    console.log(`Channel ${channel}: No audio`);\r\n  }\r\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"multi-channel-dashboard",children:"Multi-Channel Dashboard"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:'class MultiChannelDashboard {\r\n  private dashboardElement: HTMLElement | null = null;\r\n  private updateInterval: number | null = null;\r\n\r\n  constructor() {\r\n    this.dashboardElement = document.getElementById(\'channel-dashboard\');\r\n    this.startDashboard();\r\n  }\r\n\r\n  private startDashboard(): void {\r\n    this.updateInterval = setInterval(() => {\r\n      this.updateDashboard();\r\n    }, 500); // Update every 500ms\r\n  }\r\n\r\n  private updateDashboard(): void {\r\n    const allChannels = getAllChannelsInfo();\r\n    \r\n    if (!this.dashboardElement) return;\r\n\r\n    let dashboardHTML = \'<h2>Audio Channel Dashboard</h2>\';\r\n    \r\n    // Show channels 0-4\r\n    for (let i = 0; i < 5; i++) {\r\n      const channelInfo = allChannels[i];\r\n      \r\n      if (channelInfo) {\r\n        const progress = Math.round((channelInfo.currentTime / channelInfo.duration) * 100);\r\n        const volume = Math.round(channelInfo.volume * 100);\r\n        const status = channelInfo.isPaused ? \'\u23f8\ufe0f Paused\' : \'\u25b6\ufe0f Playing\';\r\n        \r\n        dashboardHTML += `\r\n          <div class="channel-info active">\r\n            <h3>Channel ${i}</h3>\r\n            <div class="track-name">${channelInfo.fileName}</div>\r\n            <div class="progress-info">Progress: ${progress}%</div>\r\n            <div class="volume-info">Volume: ${volume}%</div>\r\n            <div class="status-info">${status}</div>\r\n          </div>\r\n        `;\r\n      } else {\r\n        dashboardHTML += `\r\n          <div class="channel-info inactive">\r\n            <h3>Channel ${i}</h3>\r\n            <div class="no-audio">No audio playing</div>\r\n          </div>\r\n        `;\r\n      }\r\n    }\r\n    \r\n    this.dashboardElement.innerHTML = dashboardHTML;\r\n  }\r\n\r\n  private formatTime(milliseconds: number): string {\r\n    const seconds = Math.floor(milliseconds / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const remainingSeconds = seconds % 60;\r\n    return `${minutes}:${remainingSeconds.toString().padStart(2, \'0\')}`;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"getqueuesnapshot",children:"getQueueSnapshot"}),"\n",(0,s.jsx)(e.p,{children:"Get a complete snapshot of the current queue state for a specific channel."}),"\n",(0,s.jsx)(e.h3,{id:"syntax-2",children:"Syntax"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"getQueueSnapshot(channelNumber?: number): QueueSnapshot\n"})}),"\n",(0,s.jsx)(e.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"channelNumber"})," (number, optional): The channel number to query (defaults to 0)"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"returns-2",children:"Returns"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"QueueSnapshot"}),": Complete queue information"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"queuesnapshot-properties",children:"QueueSnapshot Properties"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface QueueSnapshot {\r\n  items: QueueItem[];\r\n  totalItems: number;\r\n  currentlyPlaying: string | null;\r\n  isChannelActive: boolean;\r\n}\r\n\r\ninterface QueueItem {\r\n  fileName: string;\r\n  duration: number;\r\n  isCurrentlyPlaying: boolean;\r\n  position: number;\r\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"examples-2",children:"Examples"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"import { getQueueSnapshot, queueAudio } from 'audio-channel-queue';\r\n\r\n// Queue multiple audio files\r\nawait queueAudio('/audio/track1.mp3');\r\nawait queueAudio('/audio/track2.mp3');\r\nawait queueAudio('/audio/track3.mp3');\r\n\r\n// Get queue snapshot (using default channel 0)\r\nconst snapshot = getQueueSnapshot();\r\n\r\nconsole.log(`Total items: ${snapshot.totalItems}`);\r\nconsole.log(`Currently playing: ${snapshot.currentlyPlaying}`);\r\nconsole.log(`Channel active: ${snapshot.isChannelActive}`);\r\n\r\nsnapshot.items.forEach((item, index) => {\r\n  const status = item.isCurrentlyPlaying ? '\u25b6\ufe0f Playing' : `#${item.position}`;\r\n  console.log(`${status}: ${item.fileName} (${item.duration}ms)`);\r\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"real-world-usage-1",children:"Real-world Usage"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:'class PlaylistViewer {\r\n  private playlistElement: HTMLElement | null = null;\r\n  private statsElement: HTMLElement | null = null;\r\n\r\n  constructor() {\r\n    this.playlistElement = document.getElementById(\'playlist\');\r\n    this.statsElement = document.getElementById(\'playlist-stats\');\r\n    this.startPlaylistUpdates();\r\n  }\r\n\r\n  private startPlaylistUpdates(): void {\r\n    setInterval(() => {\r\n      this.updatePlaylist();\r\n    }, 1000); // Update every second\r\n  }\r\n\r\n  private updatePlaylist(): void {\r\n    const snapshot = getQueueSnapshot(); // Using default channel 0\r\n    \r\n    this.updatePlaylistDisplay(snapshot);\r\n    this.updateStats(snapshot);\r\n  }\r\n\r\n  private updatePlaylistDisplay(snapshot: QueueSnapshot): void {\r\n    if (!this.playlistElement) return;\r\n\r\n    if (snapshot.totalItems === 0) {\r\n      this.playlistElement.innerHTML = \'<div class="no-playlist">No songs in queue</div>\';\r\n      return;\r\n    }\r\n\r\n    let playlistHTML = \'<h3>Current Playlist</h3><ul class="playlist-items">\';\r\n    \r\n    snapshot.items.forEach((item) => {\r\n      const statusIcon = item.isCurrentlyPlaying ? \'\u25b6\ufe0f\' : \'\u23f3\';\r\n      const itemClass = item.isCurrentlyPlaying ? \'playing\' : \'queued\';\r\n      const duration = Math.round(item.duration / 1000);\r\n      \r\n      playlistHTML += `\r\n        <li class="playlist-item ${itemClass}">\r\n          <span class="status">${statusIcon}</span>\r\n          <span class="position">${item.position}.</span>\r\n          <span class="filename">${item.fileName}</span>\r\n          <span class="duration">${duration}s</span>\r\n        </li>\r\n      `;\r\n    });\r\n    \r\n    playlistHTML += \'</ul>\';\r\n    this.playlistElement.innerHTML = playlistHTML;\r\n  }\r\n\r\n  private updateStats(snapshot: QueueSnapshot): void {\r\n    if (!this.statsElement) return;\r\n\r\n    const totalDuration = snapshot.items.reduce((sum, item) => sum + item.duration, 0);\r\n    const totalMinutes = Math.round(totalDuration / 1000 / 60);\r\n    \r\n    this.statsElement.innerHTML = `\r\n      <div class="playlist-stats">\r\n        <div class="stat">\r\n          <span class="label">Total Tracks:</span>\r\n          <span class="value">${snapshot.totalItems}</span>\r\n        </div>\r\n        <div class="stat">\r\n          <span class="label">Total Duration:</span>\r\n          <span class="value">${totalMinutes} minutes</span>\r\n        </div>\r\n        <div class="stat">\r\n          <span class="label">Channel Status:</span>\r\n          <span class="value">${snapshot.isChannelActive ? \'\ud83d\udfe2 Active\' : \'\ud83d\udd34 Inactive\'}</span>\r\n        </div>\r\n        <div class="stat">\r\n          <span class="label">Now Playing:</span>\r\n          <span class="value">${snapshot.currentlyPlaying || \'None\'}</span>\r\n        </div>\r\n      </div>\r\n    `;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"queue-analysis",children:"Queue Analysis"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"class QueueAnalyzer {\r\n  analyzeQueue(channel: number = 0): void {\r\n    const snapshot = channel === 0 ? getQueueSnapshot() : getQueueSnapshot(channel);\r\n    \r\n    console.log(`\\n\ud83d\udcca Queue Analysis for Channel ${channel}:`);\r\n    console.log(`   Total Items: ${snapshot.totalItems}`);\r\n    console.log(`   Currently Playing: ${snapshot.currentlyPlaying || 'Nothing'}`);\r\n    console.log(`   Channel Active: ${snapshot.isChannelActive ? 'Yes' : 'No'}`);\r\n\r\n    if (snapshot.totalItems === 0) {\r\n      console.log('   Status: \u2705 Queue is empty and ready for new audio');\r\n      return;\r\n    }\r\n\r\n    const totalDuration = snapshot.items.reduce((sum, item) => sum + item.duration, 0);\r\n    const avgDuration = totalDuration / snapshot.items.length;\r\n\r\n    console.log(`   Total Duration: ${Math.round(totalDuration / 1000)} seconds`);\r\n    console.log(`   Average Duration: ${Math.round(avgDuration / 1000)} seconds`);\r\n\r\n    // Queue health assessment\r\n    if (snapshot.totalItems > 10) {\r\n      console.log('   \u26a0\ufe0f  Warning: Large queue detected - may impact performance');\r\n    } else if (snapshot.totalItems > 5) {\r\n      console.log('   \ud83d\udcc8 Queue is moderately full');\r\n    } else {\r\n      console.log('   \u2705 Queue size is optimal');\r\n    }\r\n\r\n    // Show queue items\r\n    console.log('\\n   Queue Items:');\r\n    snapshot.items.forEach((item) => {\r\n      const status = item.isCurrentlyPlaying ? '\ud83d\udd0a Playing' : `#${item.position} Queued`;\r\n      const duration = Math.round(item.duration / 1000);\r\n      console.log(`     ${status}: ${item.fileName} (${duration}s)`);\r\n    });\r\n  }\r\n\r\n  monitorQueueHealth(): void {\r\n    setInterval(() => {\r\n      // Monitor default channel and channels 1-3\r\n      for (let channel = 0; channel < 4; channel++) {\r\n        const snapshot = channel === 0 ? getQueueSnapshot() : getQueueSnapshot(channel);\r\n        \r\n        if (snapshot.totalItems > 15) {\r\n          console.warn(`\ud83d\udea8 Channel ${channel} queue overloaded: ${snapshot.totalItems} items`);\r\n        }\r\n      }\r\n    }, 5000); // Check every 5 seconds\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"class AudioPerformanceMonitor {\r\n  private metrics = {\r\n    memoryUsage: 0,\r\n    activeTracks: 0,\r\n    queueSizes: {} as { [channel: number]: number },\r\n    lastUpdate: Date.now()\r\n  };\r\n\r\n  startMonitoring(): void {\r\n    setInterval(() => {\r\n      this.updateMetrics();\r\n      this.checkPerformance();\r\n    }, 5000); // Check every 5 seconds\r\n  }\r\n\r\n  private updateMetrics(): void {\r\n    // Get memory usage (if available)\r\n    if ('memory' in performance) {\r\n      this.metrics.memoryUsage = (performance as any).memory.usedJSHeapSize;\r\n    }\r\n\r\n    // Count active tracks across all channels\r\n    const allChannels = getAllChannelsInfo();\r\n    this.metrics.activeTracks = Object.values(allChannels)\r\n      .filter(info => info !== null).length;\r\n\r\n    // Get queue sizes\r\n    for (let i = 0; i < 8; i++) { // Check 8 channels\r\n      const snapshot = i === 0 ? getQueueSnapshot() : getQueueSnapshot(i);\r\n      this.metrics.queueSizes[i] = snapshot.totalItems;\r\n    }\r\n\r\n    this.metrics.lastUpdate = Date.now();\r\n  }\r\n\r\n  private checkPerformance(): void {\r\n    // Warn if too many active tracks\r\n    if (this.metrics.activeTracks > 10) {\r\n      console.warn(`Performance Warning: ${this.metrics.activeTracks} active tracks`);\r\n    }\r\n\r\n    // Warn if queue sizes are getting large\r\n    const totalQueued = Object.values(this.metrics.queueSizes)\r\n      .reduce((sum, size) => sum + size, 0);\r\n      \r\n    if (totalQueued > 50) {\r\n      console.warn(`Performance Warning: ${totalQueued} total queued items`);\r\n    }\r\n\r\n    // Memory warning (if available)\r\n    if (this.metrics.memoryUsage > 100 * 1024 * 1024) { // 100MB\r\n      console.warn(`Memory Warning: ${(this.metrics.memoryUsage / 1024 / 1024).toFixed(1)}MB used`);\r\n    }\r\n  }\r\n\r\n  getMetrics() {\r\n    return { ...this.metrics };\r\n  }\r\n} \n"})})]})}function d(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>o});var a=r(6540);const s={},t=a.createContext(s);function i(n){const e=a.useContext(t);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),a.createElement(t.Provider,{value:e},n.children)}}}]);